node.exe : (node:5220) 
[MODULE_TYPELESS_PACKAGE_JSON] 
Warning: Module type of file:///C:
/repos/siba/eslint.config.js?mtime
=1768634723614 is not specified 
and it doesn't parse as CommonJS.
At line:1 char:1
+ & "C:\Program 
Files\nodejs/node.exe" 
"C:\Program Files\nodejs/node_mo 
...
+ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
~~~
    + CategoryInfo          : Not 
   Specified: ((node:5220) [MO..  
  .se as CommonJS.:String) [],    
 RemoteException
    + FullyQualifiedErrorId : Nat 
   iveCommandError
 
Reparsing as ES module because 
module syntax was detected. This 
incurs a performance overhead.
To eliminate this warning, add 
"type": "module" to 
C:\repos\siba\package.json.
(Use `node --trace-warnings ...` 
to show where the warning was 
created)
[{"filePath":"C:\\repos\\siba\\apps\\api\\src\\controllers\\auth.controller.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'claveHash' is assigned a value but never used.","line":73,"column":13,"nodeType":"Identifier","messageId":"unusedVar","endLine":73,"endColumn":22},{"ruleId":"@typescript-eslint/ban-ts-comment","severity":2,"message":"Use \"@ts-expect-error\" instead of \"@ts-ignore\", as \"@ts-ignore\" will do nothing if the following line is error-free.","line":82,"column":5,"nodeType":"Line","messageId":"tsIgnoreInsteadOfExpectError","endLine":82,"endColumn":75,"suggestions":[{"messageId":"replaceTsIgnoreWithTsExpectError","fix":{"range":[2635,2705],"text":"// @ts-expect-error - El middleware de auth inyectar├í el usuario en req.user"},"desc":"Replace \"@ts-ignore\" with \"@ts-expect-error\"."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Request, Response } from 'express';\r\nimport { z } from 'zod';\r\nimport { AuthService } from '../services/auth.service';\r\n\r\n// Schema de validaci├│n para Login\r\nconst loginSchema = z.object({\r\n    email: z.string().email(),\r\n    password: z.string().min(1),\r\n});\r\n\r\nexport const login = async (req: Request, res: Response) => {\r\n    try {\r\n        const { email, password } = loginSchema.parse(req.body);\r\n\r\n        const user = await AuthService.validateUser(email, password);\r\n        if (!user) {\r\n            return res.status(401).json({ error: 'Credenciales inv├ílidas' });\r\n        }\r\n\r\n        const accessToken = AuthService.generateAccessToken(user);\r\n        const refreshToken = AuthService.generateRefreshToken(user);\r\n\r\n        // Enviar Refresh Token en Cookie HTTP-Only\r\n        res.cookie('refreshToken', refreshToken, {\r\n            httpOnly: true,\r\n            secure: process.env.NODE_ENV === 'production',\r\n            sameSite: 'lax', // Relaxed for local dev\r\n            maxAge: 7 * 24 * 60 * 60 * 1000, // 7 d├¡as\r\n        });\r\n\r\n        res.json({\r\n            user,\r\n            accessToken,\r\n        });\r\n    } catch (error) {\r\n        if (error instanceof z.ZodError) {\r\n            return res.status(400).json({ error: error.errors });\r\n        }\r\n        console.error(error);\r\n        res.status(500).json({ error: 'Error interno del servidor' });\r\n    }\r\n};\r\n\r\nexport const logout = (req: Request, res: Response) => {\r\n    res.clearCookie('refreshToken');\r\n    res.json({ message: 'Logout exitoso' });\r\n};\r\n\r\nexport const refresh = async (req: Request, res: Response) => {\r\n    console.log('[Auth] Refresh request received');\r\n    const refreshToken = req.cookies.refreshToken;\r\n\r\n    if (!refreshToken) {\r\n        console.log('[Auth] No refresh token cookie');\r\n        return res.status(401).json({ error: 'No refresh token provided' });\r\n    }\r\n\r\n    const payload = AuthService.verifyRefreshToken(refreshToken);\r\n    if (!payload) {\r\n        console.log('[Auth] Invalid refresh token');\r\n        return res.status(403).json({ error: 'Invalid refresh token' });\r\n    }\r\n\r\n    const user = await AuthService.getUserById(payload.id);\r\n    if (!user) {\r\n        return res.status(403).json({ error: 'User not found' });\r\n    }\r\n\r\n    const newAccessToken = AuthService.generateAccessToken(user);\r\n    // Opcional: Rotar refresh token tambi├⌐n\r\n\r\n    // No devolver la contrase├▒a\r\n    const { claveHash, ...userWithoutPass } = user;\r\n\r\n    res.json({\r\n        accessToken: newAccessToken,\r\n        user: userWithoutPass\r\n    });\r\n};\r\n\r\nexport const me = async (req: Request, res: Response) => {\r\n    // @ts-ignore - El middleware de auth inyectar├í el usuario en req.user\r\n    const user = req.user;\r\n    res.json({ user });\r\n};\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\repos\\siba\\apps\\api\\src\\controllers\\role.controller.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\repos\\siba\\apps\\api\\src\\controllers\\user.controller.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'_claveHash' is assigned a value but never used.","line":64,"column":32,"nodeType":"Identifier","messageId":"unusedVar","endLine":64,"endColumn":42},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'_claveHash' is assigned a value but never used.","line":139,"column":28,"nodeType":"Identifier","messageId":"unusedVar","endLine":139,"endColumn":38},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'_claveHash' is assigned a value but never used.","line":188,"column":28,"nodeType":"Identifier","messageId":"unusedVar","endLine":188,"endColumn":38}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Request, Response } from 'express';\r\nimport { z } from 'zod';\r\nimport { prisma } from '../index';\r\nimport { AuthService } from '../services/auth.service';\r\n\r\n// --- Schemas ---\r\nconst createUserSchema = z.object({\r\n    email: z.string().email(),\r\n    nombre: z.string().min(1),\r\n    apellido: z.string().min(1),\r\n    password: z.string().min(6),\r\n    rolId: z.number().int().positive(), // Por ahora asignamos un solo rol principal\r\n});\r\n\r\nconst updateUserSchema = z.object({\r\n    email: z.string().email().optional(),\r\n    nombre: z.string().min(1).optional(),\r\n    apellido: z.string().min(1).optional(),\r\n    password: z.string().min(6).optional(),\r\n    rolId: z.number().int().positive().optional(),\r\n});\r\n\r\n// --- Controller Methods ---\r\n\r\nexport const getAll = async (req: Request, res: Response) => {\r\n    try {\r\n        const page = Number(req.query.page) || 1;\r\n        const limit = Number(req.query.limit) || 10;\r\n        const search = req.query.search as string;\r\n\r\n        const skip = (page - 1) * limit;\r\n\r\n        const whereClause: { fechaEliminacion: null; OR?: { nombre?: { contains: string; mode: 'insensitive' }; apellido?: { contains: string; mode: 'insensitive' }; email?: { contains: string; mode: 'insensitive' } }[] } = {\r\n            fechaEliminacion: null, // Solo activos\r\n        };\r\n\r\n        if (search) {\r\n            whereClause.OR = [\r\n                { nombre: { contains: search, mode: 'insensitive' } },\r\n                { apellido: { contains: search, mode: 'insensitive' } },\r\n                { email: { contains: search, mode: 'insensitive' } },\r\n            ];\r\n        }\r\n\r\n        const [total, users] = await prisma.$transaction([\r\n            prisma.usuario.count({ where: whereClause }),\r\n            prisma.usuario.findMany({\r\n                where: whereClause,\r\n                skip,\r\n                take: limit,\r\n                orderBy: { fechaCreacion: 'desc' },\r\n                include: {\r\n                    roles: {\r\n                        include: {\r\n                            rol: true,\r\n                        },\r\n                    },\r\n                },\r\n            }),\r\n        ]);\r\n\r\n        // Limpiar passwords\r\n        const safeUsers = users.map((u) => {\r\n            const { claveHash: _claveHash, ...rest } = u;\r\n            return {\r\n                ...rest,\r\n                roles: u.roles.map((r) => r.rol.nombre),\r\n            };\r\n        });\r\n\r\n        res.json({\r\n            data: safeUsers,\r\n            meta: {\r\n                total,\r\n                page,\r\n                limit,\r\n                totalPages: Math.ceil(total / limit),\r\n            },\r\n        });\r\n    } catch (error) {\r\n        console.error(error);\r\n        res.status(500).json({ error: 'Error al obtener usuarios' });\r\n    }\r\n};\r\n\r\nexport const getOne = async (req: Request, res: Response) => {\r\n    try {\r\n        const id = Number(req.params.id);\r\n        const user = await AuthService.getUserById(id);\r\n\r\n        if (!user) {\r\n            return res.status(404).json({ error: 'Usuario no encontrado' });\r\n        }\r\n\r\n        res.json(user);\r\n    } catch (error) {\r\n        console.error(error);\r\n        res.status(500).json({ error: 'Error al obtener usuario' });\r\n    }\r\n};\r\n\r\nexport const create = async (req: Request, res: Response) => {\r\n    try {\r\n        const body = createUserSchema.parse(req.body);\r\n\r\n        // Verificar email duplicado\r\n        const existing = await prisma.usuario.findUnique({\r\n            where: { email: body.email },\r\n        });\r\n        if (existing) {\r\n            return res.status(400).json({ error: 'El email ya est├í registrado' });\r\n        }\r\n\r\n        const hashedPassword = await AuthService.hashPassword(body.password);\r\n\r\n        const matchRole = await prisma.rol.findUnique({\r\n            where: { id: body.rolId }\r\n        });\r\n\r\n        if (!matchRole) {\r\n            return res.status(400).json({ error: 'Rol inv├ílido' });\r\n        }\r\n\r\n        // Crear usuario + Relaci├│n Rol\r\n        const newUser = await prisma.usuario.create({\r\n            data: {\r\n                email: body.email,\r\n                nombre: body.nombre,\r\n                apellido: body.apellido,\r\n                claveHash: hashedPassword,\r\n                roles: {\r\n                    create: {\r\n                        rolId: body.rolId // Asignar rol\r\n                    }\r\n                }\r\n            },\r\n        });\r\n\r\n        const { claveHash: _claveHash, ...safeUser } = newUser;\r\n        res.status(201).json(safeUser);\r\n\r\n    } catch (error) {\r\n        if (error instanceof z.ZodError) {\r\n            return res.status(400).json({ error: error.errors });\r\n        }\r\n        console.error(error);\r\n        res.status(500).json({ error: 'Error al crear usuario' });\r\n    }\r\n};\r\n\r\nexport const update = async (req: Request, res: Response) => {\r\n    try {\r\n        const id = Number(req.params.id);\r\n        const body = updateUserSchema.parse(req.body);\r\n\r\n        const user = await prisma.usuario.findUnique({ where: { id } });\r\n        if (!user) return res.status(404).json({ error: 'Usuario no encontrado' });\r\n\r\n        const dataToUpdate: { nombre?: string; apellido?: string; email?: string; claveHash?: string } = {\r\n            nombre: body.nombre,\r\n            apellido: body.apellido,\r\n            email: body.email,\r\n        };\r\n\r\n        if (body.password) {\r\n            dataToUpdate.claveHash = await AuthService.hashPassword(body.password);\r\n        }\r\n\r\n        // Si cambia rol\r\n        // Esto es complejo porque es N:N (aunque modelado 1:N en la UI por ahora)\r\n        // Para simplificar, si viene rolId, borramos los anteriores y ponemos el nuevo\r\n        // OJO: En production requerir├¡a transacci├│n\r\n        if (body.rolId) {\r\n            await prisma.usuarioRol.deleteMany({ where: { usuarioId: id } });\r\n            await prisma.usuarioRol.create({\r\n                data: {\r\n                    usuarioId: id,\r\n                    rolId: body.rolId\r\n                }\r\n            });\r\n        }\r\n\r\n        const updatedUser = await prisma.usuario.update({\r\n            where: { id },\r\n            data: dataToUpdate,\r\n        });\r\n\r\n        const { claveHash: _claveHash, ...safeUser } = updatedUser;\r\n        res.json(safeUser);\r\n\r\n    } catch (error) {\r\n        if (error instanceof z.ZodError) {\r\n            return res.status(400).json({ error: error.errors });\r\n        }\r\n        console.error(error);\r\n        res.status(500).json({ error: 'Error al actualizar usuario' });\r\n    }\r\n};\r\n\r\nexport const deleteOne = async (req: Request, res: Response) => {\r\n    try {\r\n        const id = Number(req.params.id);\r\n\r\n        // Soft Delete\r\n        await prisma.usuario.update({\r\n            where: { id },\r\n            data: { fechaEliminacion: new Date() },\r\n        });\r\n\r\n        res.json({ message: 'Usuario eliminado correctamente' });\r\n    } catch (error) {\r\n        console.error(error);\r\n        res.status(500).json({ error: 'Error al eliminar usuario' });\r\n    }\r\n};\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\repos\\siba\\apps\\api\\src\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\repos\\siba\\apps\\api\\src\\middlewares\\auth.middleware.ts","messages":[{"ruleId":"@typescript-eslint/no-namespace","severity":2,"message":"ES2015 module syntax is preferred over namespaces.","line":8,"column":5,"nodeType":"TSModuleDeclaration","messageId":"moduleSyntaxIsPreferred","endLine":12,"endColumn":6},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":10,"column":20,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":10,"endColumn":23,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[309,312],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[309,312],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":24,"column":41,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":24,"endColumn":44,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[761,764],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[761,764],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":24,"column":52,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":24,"endColumn":55,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[772,775],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[772,775],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":4,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Request, Response, NextFunction } from 'express';\r\nimport jwt from 'jsonwebtoken';\r\n\r\nconst JWT_SECRET = process.env.JWT_SECRET || 'default-secret';\r\n\r\n// Extender la interfaz Request para incluir el usuario\r\ndeclare global {\r\n    namespace Express {\r\n        interface Request {\r\n            user?: any;\r\n        }\r\n    }\r\n}\r\n\r\nexport const authenticateToken = (req: Request, res: Response, next: NextFunction) => {\r\n    const authHeader = req.headers['authorization'];\r\n    const token = authHeader && authHeader.split(' ')[1]; // Bearer TOKEN\r\n\r\n    if (!token) {\r\n        console.log('[AuthMiddleware] No token provided');\r\n        return res.status(401).json({ error: 'Token no proporcionado' });\r\n    }\r\n\r\n    jwt.verify(token, JWT_SECRET, (err: any, user: any) => {\r\n        if (err) {\r\n            console.log('[AuthMiddleware] Token verify error:', err.message);\r\n            // Si el token expir├│, devolver 401 para trigger de refresh en frontend\r\n            return res.status(401).json({ error: 'Token inv├ílido o expirado' });\r\n        }\r\n        req.user = user;\r\n        next();\r\n    });\r\n};\r\n\r\nexport const requireRole = (role: string) => {\r\n    return (req: Request, res: Response, next: NextFunction) => {\r\n        if (!req.user) {\r\n            return res.status(401).json({ error: 'No autenticado' });\r\n        }\r\n\r\n        // Comparaci├│n de roles (Array)\r\n        // Se asume que req.user.roles viene populado del token o del auth middleware\r\n        const userRoles = req.user.roles || [];\r\n        if (!userRoles.includes(role) && !userRoles.includes('Super Admin')) {\r\n            return res.status(403).json({ error: 'Permisos insuficientes' });\r\n        }\r\n\r\n        next();\r\n    };\r\n};\r\n\r\n// Middleware para verificar permisos espec├¡ficos\r\nexport const requirePermission = (permissionCode: string) => {\r\n    return (req: Request, res: Response, next: NextFunction) => {\r\n        if (!req.user) {\r\n            return res.status(401).json({ error: 'No autenticado' });\r\n        }\r\n\r\n        const userRoles: string[] = req.user.roles || [];\r\n        const userPermisos: string[] = req.user.permisos || [];\r\n\r\n        // Super Admin siempre tiene acceso\r\n        if (userRoles.includes('Super Admin')) {\r\n            return next();\r\n        }\r\n\r\n        // Verificar si tiene el permiso espec├¡fico\r\n        if (userPermisos.includes(permissionCode)) {\r\n            return next();\r\n        }\r\n\r\n        console.log(`[AuthMiddleware] Permiso denegado: ${permissionCode} para usuario ${req.user.email}`);\r\n        return res.status(403).json({\r\n            error: 'Permiso insuficiente',\r\n            required: permissionCode\r\n        });\r\n    };\r\n};\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\repos\\siba\\apps\\api\\src\\routes\\auth.routes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\repos\\siba\\apps\\api\\src\\routes\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\repos\\siba\\apps\\api\\src\\routes\\role.routes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\repos\\siba\\apps\\api\\src\\routes\\user.routes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\repos\\siba\\apps\\api\\src\\services\\auth.service.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'_claveHash' is assigned a value but never used.","line":64,"column":28,"nodeType":"Identifier","messageId":"unusedVar","endLine":64,"endColumn":38},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":101,"column":61,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":101,"endColumn":64,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3005,3008],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3005,3008],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'e' is defined but never used.","line":102,"column":18,"nodeType":"Identifier","messageId":"unusedVar","endLine":102,"endColumn":19},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'_claveHash' is assigned a value but never used.","line":135,"column":28,"nodeType":"Identifier","messageId":"unusedVar","endLine":135,"endColumn":38}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { PrismaClient } from '@prisma/client';\r\nimport bcrypt from 'bcryptjs';\r\nimport jwt, { type SignOptions } from 'jsonwebtoken';\r\n\r\nconst prisma = new PrismaClient();\r\n\r\nconst JWT_SECRET = process.env.JWT_SECRET || 'default-secret';\r\nconst JWT_REFRESH_SECRET = process.env.JWT_REFRESH_SECRET || 'default-refresh-secret';\r\nconst JWT_EXPIRES_IN = process.env.JWT_EXPIRES_IN || '15m';\r\nconst JWT_REFRESH_EXPIRES_IN = process.env.JWT_REFRESH_EXPIRES_IN || '7d';\r\n\r\n// Interfaces para tipado de JWT\r\ninterface UserPayload {\r\n    id: number;\r\n    email: string;\r\n    roles: string[];\r\n    permisos: string[];\r\n}\r\n\r\ninterface RefreshPayload {\r\n    id: number;\r\n}\r\n\r\nexport class AuthService {\r\n    // Hashear contrase├▒a\r\n    static async hashPassword(pass: string) {\r\n        return await bcrypt.hash(pass, 10);\r\n    }\r\n\r\n    // Verificar credenciales del usuario\r\n    static async validateUser(email: string, pass: string) {\r\n        const user = await prisma.usuario.findUnique({\r\n            where: { email },\r\n            include: {\r\n                roles: {\r\n                    include: {\r\n                        rol: {\r\n                            include: {\r\n                                permisos: {\r\n                                    include: {\r\n                                        permiso: true\r\n                                    }\r\n                                }\r\n                            },\r\n                        },\r\n                    },\r\n                },\r\n            },\r\n        });\r\n\r\n        if (!user) return null;\r\n\r\n        // Verificar contrase├▒a\r\n        const isValid = await bcrypt.compare(pass, user.claveHash);\r\n        if (!isValid) return null;\r\n\r\n        // Aplanar estructura\r\n        const roles = user.roles.map(r => r.rol.nombre);\r\n        const permisos = Array.from(new Set(\r\n            user.roles.flatMap(r => r.rol.permisos.map(rp => rp.permiso.codigo))\r\n        ));\r\n\r\n        // No devolver la contrase├▒a\r\n        const { claveHash: _claveHash, ...userWithoutPass } = user;\r\n\r\n        return {\r\n            ...userWithoutPass,\r\n            roles,\r\n            permisos\r\n        };\r\n    }\r\n\r\n    // Generar Access Token\r\n    static generateAccessToken(user: UserPayload): string {\r\n        return jwt.sign(\r\n            {\r\n                id: user.id,\r\n                email: user.email,\r\n                roles: user.roles,\r\n                permisos: user.permisos,\r\n            },\r\n            JWT_SECRET,\r\n            { expiresIn: JWT_EXPIRES_IN } as SignOptions\r\n        );\r\n    }\r\n\r\n    // Generar Refresh Token\r\n    static generateRefreshToken(user: RefreshPayload): string {\r\n        return jwt.sign(\r\n            {\r\n                id: user.id,\r\n            },\r\n            JWT_REFRESH_SECRET,\r\n            { expiresIn: JWT_REFRESH_EXPIRES_IN } as SignOptions\r\n        );\r\n    }\r\n\r\n    // Verificar Refresh Token\r\n    static verifyRefreshToken(token: string) {\r\n        try {\r\n            return jwt.verify(token, JWT_REFRESH_SECRET) as any;\r\n        } catch (e) {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    // Obtener usuario por ID (num├⌐rico)\r\n    static async getUserById(id: number) {\r\n        const user = await prisma.usuario.findUnique({\r\n            where: { id },\r\n            include: {\r\n                roles: {\r\n                    include: {\r\n                        rol: {\r\n                            include: {\r\n                                permisos: {\r\n                                    include: {\r\n                                        permiso: true\r\n                                    }\r\n                                }\r\n                            },\r\n                        },\r\n                    },\r\n                },\r\n            },\r\n        });\r\n\r\n        if (!user) return null;\r\n\r\n        const roles = user.roles.map(r => r.rol.nombre);\r\n        const permisos = Array.from(new Set(\r\n            user.roles.flatMap(r => r.rol.permisos.map(rp => rp.permiso.codigo))\r\n        ));\r\n\r\n        const { claveHash: _claveHash, ...userWithoutPass } = user;\r\n        return {\r\n            ...userWithoutPass,\r\n            roles,\r\n            permisos\r\n        };\r\n    }\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\repos\\siba\\apps\\api\\src\\utils\\logger.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]}]
